import * as fs from 'fs/promises';
import { TASK_CIRCOM_TEMPLATE, ZkeyFastFile } from 'hardhat-circom';
import { subtask } from 'hardhat/config';
import { HardhatRuntimeEnvironment } from 'hardhat/types';
import * as path from 'path';

subtask(TASK_CIRCOM_TEMPLATE, 'replace hardhat-circom templating with custom').setAction(
  circomTemplate
);

async function circomTemplate(
  { zkeys }: { zkeys: ZkeyFastFile[] },
  hre: HardhatRuntimeEnvironment
) {
  let finalSol = '';
  for (const zkey of zkeys) {
    const userTemplate = `
      function ${zkey.name}VerifyingKey() internal pure returns (VerifyingKey memory vk) {
        vk.alfa1 = Pairing.G1Point(<%vk_alpha1%>);
        vk.beta2 = Pairing.G2Point(<%vk_beta2%>);
        vk.gamma2 = Pairing.G2Point(<%vk_gamma2%>);
        vk.delta2 = Pairing.G2Point(<%vk_delta2%>);
        vk.IC = new Pairing.G1Point[](<%vk_ic_length%>);
      <%vk_ic_pts%>
      }

      function verify${zkey.name.charAt(0).toUpperCase() + zkey.name.slice(1)}Proof(
          uint256[2] memory a,
          uint256[2][2] memory b,
          uint256[2] memory c,
          uint256[<%vk_input_length%>] memory input
      ) public view returns (bool) {
          uint256[] memory inputValues = new uint256[](input.length);
          for (uint256 i = 0; i < input.length; i++) {
              inputValues[i] = input[i];
          }
          return verifyProof(a, b, c, inputValues, ${zkey.name}VerifyingKey());
      }`;

    const circuitSol = await hre.snarkjs.zKey.exportSolidityVerifier(
      zkey,
      // strings are opened as relative path files, so turn into an array of bytes
      new TextEncoder().encode(userTemplate)
    );

    finalSol = finalSol.concat(circuitSol);
  }

  const verifierTemplatePath = path.join(
    hre.config.paths.root,
    '..',
    'circuits',
    'Verifier.sol.template'
  );
  const verifier = path.join(hre.config.paths.sources, 'Verifier.sol');

  const warning = `// SPDX-License-Identifier: MIT\n// THIS FILE IS GENERATED BY HARDHAT-CIRCOM. DO NOT EDIT THIS FILE.\n\n`;
  const template = warning + (await fs.readFile(verifierTemplatePath)).toString();

  await fs.mkdir(path.dirname(verifier), { recursive: true });

  await fs.writeFile(verifier, template.replace(/<%full_circuit%>/g, finalSol));
}
